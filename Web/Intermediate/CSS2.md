# CSS
CSS是一门基于规则的语言，定义用于你的网页中特定元素样式的一组规则。

**添加CSS**
在文档的开头链接CSS
    <link rel="stylesheet" href="style.css">

**类选择器**
```css
.special {
  color: orange;
  font-weight: bold;
}
```

# 构建CSS
**外部样式表**
外部样式表是指将 CSS 编写在扩展名为.css 的单独文件中，并从 HTML `<link>` 元素引用它的情况。
    <link rel="stylesheet" href="styles/style.css">

**内部样式表**
内部样式表是指不使用外部 CSS 文件，而是将 CSS 放在 HTML 文件`<head>`标签里的`<style>`标签之中。
    <style></style>

**内联样式**
内联样式表存在于 HTML 元素的 style 属性之中。(尽量不要使用，难以维护)
    <h1 style=""></h1>

优先级：为p选择器定义两个规则，后一个会覆盖前面一个。类选择器优先级高于元素选择器。

**@规则**
要将额外的样式表导入主CSS样式表，可以使用@import
    @import 'style2.css';

媒体查询：根据各种设备特征和参数的值或者是否存在来调整网站或应用。
@media允许使用媒体查询来应用CSS，仅当某些条件成立。

该查询将根据视口宽度更改样式。

```css
body {
    background-color: pink;
}

@media (min-width: 30em) {
    body {
        background-color: blue;
    }
}
```

**速记属性**
padding: 上 下 左 右
background：

**注释**
CSS 中的注释以 /* 开头，以 */ 结尾。

# CSS如何运行
![](https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/How_CSS_works/rendering.svg)

1. 浏览器载入HTML文件
2. 将HTML文件转化成一个DOM（document object model）,DOM是文件在计算机内存中的表现形式。
3. 浏览器会拉取该HTML相关的大部分资源，比如图片、视频和CSS样式。
4. 浏览器拉取到CSS之后进行解析。根据选择器的不同类型把它们分到不同的桶中。浏览器基于它找到的不同的选择器，将不同的规则应用到对应的DOM的节点中，并添加节点依赖的样式。
5. 上述的规则应用于渲染树后，渲染树会依照应该出现的结构进行布局。
6. 网页展示在屏幕上。

一个DOM有一个树形结构，标记语言中的每一个元素、属性以及每一段文字都对应着结构树中的一个节点。

一个好的实践：
当浏览器遇到无法解析的CSS代码会直接跳过，当实验新特性时，考虑将新特性放在后面，如果浏览器支持，直接覆盖直接的参数，如果不支持，浏览器会忽略它。

# CSS构建
**选择器**
选择器告诉浏览器哪个 HTML 元素应当是被选为应用规则中的 CSS 属性值的方式。

**选择器列表**
如果有多个使用相同样式的 CSS 选择器，那么这些单独的选择器可以被混编为一个“选择器列表”，这样，规则就可以应用到所有的单个选择器上了。

**类型选择器**
类型选择器也叫标签名选择器或者元素选择器，因为它咋文档中选择了一个HTML标签/元素。
    h1 {}

**全局选择器**
全局选择器，是由一个星号（*）代指的，它选中了文档中的所有内容。
    * {}

**类选择器**
类选择器以一个句点（.）开头，会选择文档中应用了这个类的所有物件。
    .box {}
    .box.warning {}

**ID选择器**
ID 选择器开头为#而非句点，不过基本上和类选择器是同种用法。可是在一篇文档中，一个 ID 只会用到一次。它能选中设定了id的元素，你可以在 ID 前面加上类型选择器，只指向元素和 ID 都匹配的类。

**伪类和伪元素**
伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。
- `:first-child`: 表示在一组兄弟元素中的第一个元素
- `:last-child`:

用户行为伪类
`:hover`：用户将指针挪到元素上的时候才会激活
`:focus`：只会在用户使用键盘控制，选定元素的时候激活

伪元素
伪元素表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号::。

生成带有::before和::after的内容
从CSS插入文本字符串
这些伪元素的更推荐的用法是插入一个图标，例如下加入一个小箭头。

**关系选择器**
后代选择器
后代选择器——典型用单个空格（" "）字符——组合两个选择器
    body article p

子代关系选择器
子代关系选择器是个大于号（>），只会在选择器选中直接子元素的时候匹配。
    article > p

**层叠与继承**
冲突规则
当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。
优先级
类选择器优先级高于元素选择器。
继承
一些设置在父元素上的 CSS 属性是可以被子元素继承的。

控制继承
- inherit：使子元素和父元素相同，开启继承
- initial：将元素的属性值设置为该属性的初始值
- revert：将元素的属性值重置为浏览器的默认样式，而不是应用于该属性的默认值，类似于unset
- revert-layer：将元素的属性值重置为上一个层叠层中建立的值
- unset：将属性重置为自然值，如果属性是自然继承那么是inherit，否则和initial一样

重设所有属性
    all: unset

浏览器是如何计算优先级的
本质上，不同类型的选择器有不同的分数值，把这些分数相加就得到特定选择器的权重，然后就可以进行匹配。
- ID：选择器中包含 ID 选择器则百位得一分。
- 类：选择器中包含类选择器、属性选择器或者伪类则十位得一分。
- 元素：选择器中包含元素、伪元素选择器则个位得一分。

!import
特殊的 CSS 可以用来覆盖所有上面所有优先级计算，不过需要很小心的使用。

CSS位置的影响
相互冲突的声明将按以下顺序应用，后一种声明将覆盖前一种声明：

# 盒模型

**块级盒子**
- 每个盒子都会换行
- 内边距（padding）, 外边距（margin）和 边框（border）会将其他元素从当前盒子周围“推开”

**内联盒子**
- 盒子不会产生换行

**盒模型的各个部分**
![](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model/box-model.png)

- content box: 显示内容，大小通过width和heigth设置
- padding box：包含在内容区域外部的空包区域，大小通过padding设置
- border box：边框包裹内容和内边距，大小通过border相关属性设置
- margin box：盒子与其他元素之间的空白区域，大小通过margin相关属性设置

标准盒模型
使用标准盒模型。实际占用宽高为：width/height + padding*2 + border*2

替代盒模型
设置box-sizing: border-box，内容宽高是该宽度减去边框和填充部分。

**外边距**
外边距折叠，如果你有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小。


**边框**
边框是在边距和填充框之间绘制的。如果您正在使用标准的盒模型，边框的大小将添加到框的宽度和高度。如果您使用的是替代盒模型，那么边框的大小会使内容框更小，因为它会占用一些可用的宽度和高度。

**内边距**
内边距位于边框和内容区域之间。与外边距不同，您不能有负数量的内边距，所以值必须是 0 或正的值。应用于元素的任何背景都将显示在内边距后面，内边距通常用于将内容推离边框。

**背景和边框**
background-color
background-image: rul()

background-repeat属性用于控制图像的平铺行为：
- no-repeat：不重复
- repeat-x: 水平重复
- repeat-y: 垂直重复
- repeat：在两个方向重复

调整背景图像大小
background-size
- cover: 浏览器将使图像足够大，使它完全覆盖了盒子区，同时仍然保持其高宽比。在这种情况下，有些图像可能会跳出盒子外
- contain: 浏览器将使图像的大小适合盒子内。在这种情况下，如果图像的长宽比与盒子的长宽比不同，则可能在图像的任何一边或顶部和底部出现间隙。

背景图像定位
background-position属性允许您选择背景图像显示在其应用到的盒子中的位置。它使用的坐标系中，框的左上角是 (0,0)，框沿着水平 (x) 和垂直 (y) 轴定位。

**边框**
圆角
border-radius

**溢出的内容**
溢出是在你往盒子里面塞太多东西的时候发生的。
overflow属性控制一个元素溢出的方式，默认为visible。
如果想在内容溢出的时候把它裁剪掉，你可以在你的盒子上设置overflow: hidden。
如果在有内容溢出的时候加个滚动条，overflow: scroll。

**CSS值与单位**
绝对长度单位
px：像素

相对长度单位
em：父元素的字体大小
rem：根元素的字体大小
vw：视口宽度的1%
vh：视口高度的1%

**基本文本和字体样式**
text-shadow：文字阴影

文本布局
text-align: left/right/center
justify: 使文本展开，改变单词之间的差距，使所有文本行的宽度相同

# CSS布局

在 css 中实现页面布局的主要方法是设定display属性的值display属性。

**弹性盒子**
它被专门设计出来用于创建横向或是纵向的一维页面布局。
在想要进行 flex 布局的父元素上应用display: flex ，所有直接子元素都将会按照 flex 进行布局。

![](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flex_terms.png)

当元素表现为 flex 框时，它们沿着两个轴来布局：
- 主轴（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 main start 和 main end。
- 交叉轴（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 cross start 和 cross end。

flex-direction定主轴的方向，默认值是 row。

当你在布局中使用定宽或者定高的时候，可能会出现问题即处于容器中的弹性盒子子元素会溢出，破坏了布局。flex-wrap: wrap，任何溢出都会向下移动到下一行。

flex项的动态尺寸
flex：1
这是一个无单位的比例值，表示每个 flex 项沿主轴的可用空间大小。

**水平和垂直对齐**
align-item: 控制 flex 项在交叉轴上的位置,默认的值是 stretch，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。
justfy-content: 控制 flex 项在主轴上的位置,默认值是 flex-start，这会使所有 flex 项都位于主轴的开始处

**响应式设计**
早年设计 Web 时，页面是以适配特定的屏幕大小为考量创建的。随着人们使用的屏幕尺寸的种类越来越多，出现了响应式网页设计的概念，指的是允许 Web 页面适应不同屏幕宽度因素等，进行布局和外观的调整的一系列实践。

固定宽度站点的一个可能的后果是，在比站点更窄的屏幕上会出现一个水平滚动条（如下所示），在大屏幕上的设计边缘还会有许多空白。



