# CSS
CSS是一门基于规则的语言，定义用于你的网页中特定元素样式的一组规则。

**添加CSS**
在文档的开头链接CSS
    <link rel="stylesheet" href="style.css">

**类选择器**
```css
.special {
  color: orange;
  font-weight: bold;
}
```

# 构建CSS
**外部样式表**
外部样式表是指将 CSS 编写在扩展名为.css 的单独文件中，并从 HTML `<link>` 元素引用它的情况。
    <link rel="stylesheet" href="styles/style.css">

**内部样式表**
内部样式表是指不使用外部 CSS 文件，而是将 CSS 放在 HTML 文件`<head>`标签里的`<style>`标签之中。
    <style></style>

**内联样式**
内联样式表存在于 HTML 元素的 style 属性之中。(尽量不要使用，难以维护)
    <h1 style=""></h1>

优先级：为p选择器定义两个规则，后一个会覆盖前面一个。类选择器优先级高于元素选择器。

**@规则**
要将额外的样式表导入主CSS样式表，可以使用@import
    @import 'style2.css';

媒体查询：根据各种设备特征和参数的值或者是否存在来调整网站或应用。
@media允许使用媒体查询来应用CSS，仅当某些条件成立。

该查询将根据视口宽度更改样式。

```css
body {
    background-color: pink;
}

@media (min-width: 30em) {
    body {
        background-color: blue;
    }
}
```

**速记属性**
padding: 上 下 左 右
background：

**注释**
CSS 中的注释以 /* 开头，以 */ 结尾。

# CSS如何运行
![](https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/How_CSS_works/rendering.svg)

1. 浏览器载入HTML文件
2. 将HTML文件转化成一个DOM（document object model）,DOM是文件在计算机内存中的表现形式。
3. 浏览器会拉取该HTML相关的大部分资源，比如图片、视频和CSS样式。
4. 浏览器拉取到CSS之后进行解析。根据选择器的不同类型把它们分到不同的桶中。浏览器基于它找到的不同的选择器，将不同的规则应用到对应的DOM的节点中，并添加节点依赖的样式。
5. 上述的规则应用于渲染树后，渲染树会依照应该出现的结构进行布局。
6. 网页展示在屏幕上。

一个DOM有一个树形结构，标记语言中的每一个元素、属性以及每一段文字都对应着结构树中的一个节点。

一个好的实践：
当浏览器遇到无法解析的CSS代码会直接跳过，当实验新特性时，考虑将新特性放在后面，如果浏览器支持，直接覆盖直接的参数，如果不支持，浏览器会忽略它。

# CSS构建
**选择器**
选择器告诉浏览器哪个 HTML 元素应当是被选为应用规则中的 CSS 属性值的方式。

**选择器列表**
如果有多个使用相同样式的 CSS 选择器，那么这些单独的选择器可以被混编为一个“选择器列表”，这样，规则就可以应用到所有的单个选择器上了。

**类型选择器**
类型选择器也叫标签名选择器或者元素选择器，因为它咋文档中选择了一个HTML标签/元素。
    h1 {}

**全局选择器**
全局选择器，是由一个星号（*）代指的，它选中了文档中的所有内容。
    * {}

**类选择器**
类选择器以一个句点（.）开头，会选择文档中应用了这个类的所有物件。
    .box {}
    .box.warning {}

**ID选择器**
ID 选择器开头为#而非句点，不过基本上和类选择器是同种用法。可是在一篇文档中，一个 ID 只会用到一次。它能选中设定了id的元素，你可以在 ID 前面加上类型选择器，只指向元素和 ID 都匹配的类。

**伪类和伪元素**
伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。
- `:first-child`: 表示在一组兄弟元素中的第一个元素
- `:last-child`:

用户行为伪类
`:hover`：用户将指针挪到元素上的时候才会激活
`:focus`：只会在用户使用键盘控制，选定元素的时候激活

伪元素
伪元素表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号::。

生成带有::before和::after的内容
从CSS插入文本字符串
这些伪元素的更推荐的用法是插入一个图标，例如下加入一个小箭头。

**关系选择器**
后代选择器
后代选择器——典型用单个空格（" "）字符——组合两个选择器
    body article p

子代关系选择器
子代关系选择器是个大于号（>），只会在选择器选中直接子元素的时候匹配。
    article > p

**层叠与继承**
冲突规则
当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。
优先级
类选择器优先级高于元素选择器。
继承
一些设置在父元素上的 CSS 属性是可以被子元素继承的。

控制继承
- inherit：使子元素和父元素相同，开启继承
- initial：将元素的属性值设置为该属性的初始值
- revert：将元素的属性值重置为浏览器的默认样式，而不是应用于该属性的默认值，类似于unset
- revert-layer：将元素的属性值重置为上一个层叠层中建立的值
- unset：将属性重置为自然值，如果属性是自然继承那么是inherit，否则和initial一样

重设所有属性
    all: unset

浏览器是如何计算优先级的
本质上，不同类型的选择器有不同的分数值，把这些分数相加就得到特定选择器的权重，然后就可以进行匹配。
- ID：选择器中包含 ID 选择器则百位得一分。
- 类：选择器中包含类选择器、属性选择器或者伪类则十位得一分。
- 元素：选择器中包含元素、伪元素选择器则个位得一分。

!import
特殊的 CSS 可以用来覆盖所有上面所有优先级计算，不过需要很小心的使用。

CSS位置的影响
相互冲突的声明将按以下顺序应用，后一种声明将覆盖前一种声明：

# 盒模型

**块级盒子**
- 每个盒子都会换行
- 内边距（padding）, 外边距（margin）和 边框（border）会将其他元素从当前盒子周围“推开”

**内联盒子**
- 盒子不会产生换行

**盒模型的各个部分**
![](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model/box-model.png)

- content box: 显示内容，大小通过width和heigth设置
- padding box：包含在内容区域外部的空包区域，大小通过padding设置
- border box：边框包裹内容和内边距，大小通过border相关属性设置
- margin box：盒子与其他元素之间的空白区域，大小通过margin相关属性设置

标准盒模型
使用标准盒模型。实际占用宽高为：width/height + padding*2 + border*2

替代盒模型
设置box-sizing: border-box，内容宽高是该宽度减去边框和填充部分。






